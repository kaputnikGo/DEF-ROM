
; RESET BUTTON PUSH DEMO SOUNDS CODE
; hack for Heathkit ET-3400 Audio Setup
; using PIA addr 8000 (not 0400)
; mpu clock speed is default/low (quoted as 0.5 MHz), expecting ~894750 cycles per second
; also quoted as clocked at 100kHz <- seems more likely given sound output
; not using the actual NMI, IRQ , SWI etc
; user RAM = 197 + 256 bytes = 453
; addr 0000 - 00C4 and 0100 - 01FF
; move org to 0020, fit to RAM memory map
; (0000-00BA) + (0100-013F) = (187) + (63) = 250

; refactor to DefRom only PARAM1 and SYNTH1 - FUNCTIONING (~ playback speed 50%)
; PIA sometimes pin 9 stuck hi
; some addrs not resetting when changing 0100 params
; 

;*************************************;
; MAIN LOOP mem reserve locations, have init:
0000 : 00 00                          ; clear (00)
0002 : 00 00                          ; clear (00)
0004 : 00                             ; clear (00)
0005 : 3C                             ; value 3Ch(0011 1100)
0006 :                                ;
; ~                                   ;
0019 :                                ; last used address (19 bytes)
; ~                                   ; 
001E : 00                             ;
001F : FF                             ; total 31 bytes
;*************************************;
;RESET INIT (POWER-ON) org 0020
;*************************************;
; org 0020 
0020 : 8E 01 FF   lds #$01FF          ; load SP with 01FFh
0023 : CE 80 00	  ldx #$8000          ; load X with 8000h, PIA (DAC) addr
0026 : 6F 01		  clr	$01,x           ; clear(00) addr X + 01h (8001, PIA DDR port A) 
0028 : 86 FF		  ldaa	#$FF          ; load A with FFh (1111 1111)
002A : A7 00		  staa	$00,x         ; store A in addr X + 00h (8000, port A output)
;*************************************;
;START
;*************************************;
002C : 86 3C		  ldaa	#$3C          ; load A with 3Ch(0011 1100)
002E : A7 01		  staa	$01,x         ; store A in addr X + 01h (8001)
;*************************************;
;NMI , reset/diagnostic button on board, SW1
;*************************************;
0030 : CE FF FF		ldx	#$FFFF          ; load X with value FFFFh ( or 78h )
0033 : 5F		      clrb                ; clear (00) B
0034 : E9 00		  adcb	$00,x         ; add B + X + 00h with Carry into B
0036 : 86 01		  ldaa	#$01          ; load A with value 01h (0000 0001)
;*************************************;
;PARAM1
;*************************************;
0038 : 16		      tab                 ; transfer A to B
0039 : 48		      asla                ; shift left in A
003A : 48		      asla                ; shift left in A
003B : 48		      asla                ; shift left in A
003C : 1B		      aba                 ; add A + B into A
003D : CE 00 0F		ldx	#$000F          ; load X with value 000F
0040 : DF 0B		  stx	X000B           ; store X in addr 000B ( & 000C)
0042 : CE 01 00		ldx	#$0100          ; load X with value 0100 (SAW) <- add switch? 
0045 : 8D	66      bsr L00AD           ; branch CALCOS PC + 63h(+99) to 00AD
0047 : C6 09		  ldab	#$09          ; load B with 09h (0000 1001)
;*************************************;
;UTIL1 - (loop till ACCUM B is zero, while inc X value of VVECT)
;**************************************;
0049 : 36		      psha                ; push A into stack(A into SP) 
;L004A: LOOP28
004A : A6 00		  ldaa	$00,x         ; load A with value in X + 00h
004C : DF 09		  stx	X0009           ; store X in 0009
004E : DE 0B		  ldx	X000B           ; load X with value in 000B
0050 : A7 00		  staa	$00,x         ; store A in X + 00h
0052 : 08		      inx                 ; increment X
0053 : DF 0B		  stx	X000B           ; store X in 000B
0055 : DE 09		  ldx	X0009           ; load X with value in 0009
0057 : 08		      inx                 ; increment X
0058 : 5A		      decb                ; decrement B
0059 : 26 EF		  bne	L004A           ; branch != zero PC - EFh (LOOP28)(-17)
005B : 32		      pula                ; pull into A from stack (SP into A)
;*************************************;
;SYNTH1
;*************************************;
005C : 96 17		  ldaa	X0017         ; load A with value in addr 0017
005E : B7 80 00		staa	X8000         ; store A in addr 8000 (SOUND)
;L0061: LOOP1
0061 : 96 0F		  ldaa	X000F         ; load A with value in addr 000F
0063 : 97 18		  staa	X0018         ; store A in addr 0018
0065 : 96 10		  ldaa	X0010         ; load A with value in addr 0010
0067 : 97 19		  staa	X0019         ; store A in addr 0019
;L0069: LOOP2
0069 : DE 14		  ldx	X0014           ; load X with value in 0014
;L006B: LOOP3
006B : 96 18		  ldaa	X0018         ; load A with value in addr 0018
006D : 73 80 00		com	X8000           ; complement 1s in addr 8000 (invert)(SOUND)
;L0070: LOOP4
0070 : 09		      dex                 ; decrement X (X = X - 1)
0071 : 27 10		  beq	L0083           ; branch if zero (Z = 1) to PC + 10h (GOTO1)
0073 : 4A		      deca                ; decrement A (A = A - 1)
0074 : 26 FA		  bne	L0070           ; branch != zero PC - FAh (LOOP4)(-6)
0076 : 73 80 00		com	X8000           ; complements 1s in addr 8000 (SOUND)
0079 : 96 19		  ldaa	X0019         ; load A with value in 0019
;L007B: LOOP5
007B : 09		      dex                 ; decrement X
007C : 27 05		  beq	L0083           ; branch if zero to PC + 05h (GOTO1)(+5)
007E : 4A		      deca                ; decrement A
007F : 26 FA		  bne	L007B           ; branch if not equal zero to PC - FAh (LOOP5)(-6)
0081 : 20 E8		  bra	L006B           ; branch always to addr PC - E8h (LOOP3)(-24) 
;L0083: GOTO1
0083 : B6 80 00		ldaa	X8000         ; load A with value in addr 8000 (SOUND)
0086 : 2B 01		  bmi	L0089           ; branch if minus (N = 1) to PC + 01h (GOTO2)
0088 : 43		      coma                ; complements 1s in A
;L0089: GOTO2
0089 : 8B 00		  adda	#$00          ; add A with 00h (A = A + 00h)
008B : B7 80 00		staa	X8000         ; store A in addr 8000 (SOUND)
008E : 96 18		  ldaa	X0018         ; load A with value in 0018
0090 : 9B 11		  adda	X0011         ; add A with value in addr 0011
0092 : 97 18		  staa	X0018         ; store A in addr 0018
0094 : 96 19		  ldaa	X0019         ; load A with value in 0019
0096 : 9B 12		  adda	X0012         ; add A with value in addr 0012
0098 : 97 19		  staa	X0019         ; store A in addr 0019
009A : 91 13		  cmpa	X0013         ; compare A with value in addr 0013
009C : 26 CB	  	bne	L0069           ; branch != zero to PC - CBh (LOOP2)(-53)
009E : 96 16		  ldaa	X0016         ; load A with value in 0016
00A0 : 27 06		  beq	L00A8           ; branch if zero to PC + 06h (GOTO3)
00A2 : 9B 0F			adda	X000F         ; add A with value in addr 000F
00A4 : 97 0F		  staa	X000F         ; store A in addr 000F
00A6 : 26 B9		  bne	L0061           ; branch != zero to PC - B9h (LOOP1)(-71)
;L00A8: GOTO3
00A8 : 86 02		  ldaa	#$02          ; load A with value 02h (0000 0010)
00AA : 7E 00 30		jmp L0030           ; jump to start L0030
;*************************************;
;CALCOS (calculate offset)
;*************************************;
00AD : DF 09		  stx	X0009           ; store X in 0009
00AF : 9B 0A		  adda	X000A         ; add A with value in 000A
00B1 : 97 0A		  staa	X000A         ; store A in 000A
00B3 : 24 05		  bcc	L00BA           ; branch if Carry clear to PC + 05 (GOTO46)
00B5 : 7C 00 09		inc	X0009           ; increment value in 0009
00B8 : DE 09		  ldx	X0009           ; load X with value in 0009
;L00BA: GOTO46
00BA : 39		      rts                 ; return from subroutine
;*************************************;
; must end before 00C4, org 0100 for IC16,IC17
;*************************************;
;PARAM WAVEFORM FDB (all are endless loops)
;*************************************;
0100 : 40	01 00	10 E1 00 80 FF FF     ; DEFAULT, SAW
;*************************************; 
;KNOWN PARAM WAVEFORMS (tested for PARAM1/SYNTH1)
;*************************************;
;    :|p1|p2|p3|p4|p5|p6|p7|count     ; 
0109 : 40 01 00 10 E1 00 80 FF FF     ; SAW <- 4x arpeg pulses rising
0112 : 28 01 00 08 81 02 00 FF FF     ; FOSHIT <- rising pulses, loop at high
011B : 28 81 00 FC 01 02 00 FC FF     ; QUASAR <- boot carpet
0124 : FF 01 00 18 41 04 80 00 FF     ; CABSHK <- low heavy pulses
012D : 00 FF 08 FF 68 04 80 00 FF     ; CSCADE <- 5x ramp down saws
0136 : 60 01 57 08 E1 02 00 FE 80     ; VARBG1 <- 2 tone heavy pulses oscils up !!
;*************************************; 
;EXPERIMENTAL PARAM WAVEFORMS (tested for PARAM1/SYNTH1)
;*************************************;
013F : FF 01 57 08 68 08 80 00 80     ; 
0148 : 10 01 01 18 81 02 08 00 80     ; rapid 2 tone phasing bass pulses
; 50 8b 88 3e 3f 02 3e 7c 04          ;
; 03 ff 3e 3f 2c e2 7c 12 0d          ; slow tones with pitch
; 74 7c 0d 0e 41 7c 23 0b 50          ; pitch down arpeg, slow
; 7c 1d 29 f2 7c 3f 02 3e f8          ; pitch down arpeg, not slow
; 04 03 ff 7c 3f 2c e2 f8 12          ; 2 tone pitch up arpeg, not slow
; f8 12 06 ba f8 04 07 ff 7c          ; rapid 2 tone pulses, up arpeg, long slow !!
; 37 04 c1 7c 23 05 a8 7c 12          ; rapid trill 2 tone arpegs up
; 29 23 1d 17 12 0d 08 04 08          ; rapid rand arpeg down, not slow.
; 7f d9 ff d9 7f 24 00 24 08          ; low, then hi, rand arpeg up, slow


;*************************************;
; Stack Pointer RAM addrs reserve
;*************************************;
01E8 :                                ; last SP
; ~                                   ; 23 bytes
01FF :                                ; initial SP
;*************************************;
;   outer loop : 
; vars p1, p2 | condition p1 += p6 while != 0
;   middle loop   : 
; vars count, p1 += p3, p2 += p4 | condition while p2 != p5 | p7 waveform output
;   inner loop : 
; vars p1, p2 |p7 waveform output